Design Decisions
================

Why snapshot-diff over event-based sync?

The external API returns all lists in a single GET call with no webhooks or
change feeds. A full snapshot comparison is the most reliable approach here —
it catches every difference (creates, updates, deletes) in one pass without
needing to track events or maintain a changelog.

Why last-write-wins for conflicts?

Simpler than manual merge or operational transforms, and appropriate for a
todo app where data isn't high-stakes. Ties go to external to avoid losing
data from the authoritative source. The synced_at timestamp per record lets
us detect which side changed since the last sync.

Why pull before push?

Pulling external changes first ensures we have the latest state before
pushing. This reduces stale overwrites when both sides changed.

Why per-record error handling?

One list failing (validation error, network blip) shouldn't block the rest
of the sync. Errors are collected and returned, not swallowed.


Known Limitation
================

The external API has no standalone item creation endpoint — items can only
be created with POST /todolists. New items added to already-synced lists
cannot be pushed individually. A workaround would be to DELETE and re-POST
the entire list with all items, but that risks losing the external id and
any external-side references. The safer choice is to log a warning and
leave those items for the next list-level sync opportunity.


Test Strategy
=============

One test per distinct code path — no redundant coverage. ConflictResolver
has 6 tests (one per resolution outcome), DiffCalculator has 6 (one per
diff category), and both executors have 3 each (create, update, delete).
The Orchestrator has an integration test with stubbed HTTP that exercises
the full pipeline end-to-end. WebMock stubs replace real HTTP calls so
tests stay fast and deterministic.


How to Run
==========

Tests:
  bundle exec rspec

Development (general):
  bin/rails db:seed
  bin/dev

Sync demo (all 8 scenarios in one run):

  Terminal 1 — Start mock external API:
    ruby script/mock_external_api.rb

  Terminal 2 — Seed sync test data and run sync:
    bin/rails runner db/seeds/sync.rb
    bin/rake sync:run

  Note: The sync seed (db/seeds/sync.rb) clears ALL data first, including the
  200K-item stress test list from db:seed. This is intentional — the stress
  test list would be treated as an unsynced push create, sending 200K items
  to the external API in a single request. Use db/seeds/sync.rb for sync
  testing and bin/rails db:seed for pagination/stress testing.

  Verify (optional):
    curl -s http://localhost:4000/todolists | ruby -rjson -e 'JSON.parse(STDIN.read).each { |l| puts "  #{l["name"]} (source_id: #{l["source_id"]}, items: #{l["items"].size})" }'

  Idempotency — run sync again, should report all zeros:
    bin/rake sync:run

  Scenarios tested:
    1. No action    — "Stable List" unchanged on both sides
    2. Pull create  — "New External List" created locally
    3. Push create  — Grocery Shopping, Weekend Chores, Work Tasks pushed
    4. Pull update  — "Pull Test" renamed from external
    5. Push update  — "Push Test (locally renamed)" pushed
    6. Conflict     — "Conflict - External Wins" overwrites local (newer timestamp)
                      Items: matched item updated, local-only preserved, external-only added
    7. Pull delete  — "Orphaned List" removed (external deleted)
    8. Push delete  — "Orphan Push" removed from API (local source deleted)

  To reset: restart mock API + re-run bin/rails runner db/seeds/sync.rb


What I'd Add in Production
===========================

- Scheduled execution with sidekiq-cron instead of manual rake triggers
